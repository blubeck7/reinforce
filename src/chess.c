/* This file implements the chess functionality for two agents to play against
 * each other. Tom Kerrigan's simple chess program is used to implement the
 * functionality. Names in this files are sometimes prefixed c to avoid name
 * clashes with the names in the tscp source files. 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../tscp/defs.h"
#include "../tscp/data.h"
#include "../tscp/protos.h"
#include "../inc/chess.h"


struct move_t {
	move tscp_move; //see defs.h in tscp/
	char move_str[6];
};


struct board_t {
	int color[64];
	int piece[64];
	int side;
	int castle;
	int ep;
};


struct chess_t {
	/* hash numbers for creating board hashes */
	int hash_piece[2][6][64];	
	int hash_side;
	int hash_ep[64];

	/* board state */
	int color[64];
	int piece[64];
	int side;  /* the side to move */
	int xside;
	int castle;  /* the bitfield of the castle permissions */
	int ep;  /* the en passant square. if white moves e2e4, then ep is e3 */
	int fifty;  /* the number of moves since a capture or pawn move */
	int hash;  /* a (more or less) unique number corresponding to the board */
	int ply;  /* the number of half-moves since the root of the search tree */
	int hply;  /* the number of ply since the beginning of the game */

	/* move variables */
	gen_t gen_dat[GEN_STACK]; /* space for moves generated by move functions */
	int first_move[MAX_PLY]; /* first_move[n] to first_move[n+1], excluding */

	Player *white;
	Player *black;
	char white_move[MAX_MOVES][6]; //a move is human-readable e2e4, etc.
	Board white_board[MAX_MOVES];
	char black_move[MAX_MOVES][6];
	Board black_board[MAX_MOVES];
	Move move[MAX_MOVES_TURN];
	int turn; 
	int result;
};


struct player_t { 
	char *name;  
	int color;
	Move_func *get_move;
};


/* Private prototypes */
/* hash prototypes */
static int cinit_hash(Chess *game);
static int chash_rand();
static int cset_hash(Chess *game);
/* board prototypes */
static int cinit_board(Chess *game);
/* chess prototypes */
static int cgen(Chess *game);


/* Hash functions */
/* cinit_hash
 *
 * This function sets a random 32-bit integer for color, piece and square
 * combination, a random number for white and a random number for each en
 * passant square. These random numbers are used to create a hash number for a
 * board position.
 */
static int cinit_hash(Chess *game)
{
	int i, j, k;

	srand(0);
	for (i = 0; i < 2; ++i)
		for (j = 0; j < 6; ++j)
			for (k = 0; k < 64; ++k)
				game->hash_piece[i][j][k] = chash_rand();
	game->hash_side = chash_rand();
	for (i = 0; i < 64; ++i)
		game->hash_ep[i] = chash_rand();

	return 0;
}

/* chash_rand
 * 
 * This function XORs shifted random numbers together to ensure good coverage
 * of all 32 bits.
 */

static int chash_rand()
{
	int i;
	int r = 0;

	for (i = 0; i < 32; ++i)
		r ^= rand() << i;

	return r;
}


/* cset_hash
 *
 * This function uses the Zobrist method of generating a unique number (hash)
 * for the current chess position. Of course, there are many more chess
 * positions than there are 32 bit numbers, so the numbers generated are
 * not really unique, but they're unique enough for our purposes (to detect
 * repetitions of the position). 
 * The way it works is to XOR random numbers that correspond to features of
 * the position, e.g., if there's a black knight on B8, hash is XORed with
 * hash_piece[BLACK][KNIGHT][B8]. All of the pieces are XORed together,
 * hash_side is XORed if it's black's move, and the en passant square is
 * XORed if there is one. (A chess technicality is that one position can't
 * be a repetition of another if the en passant state is different.)
 */

static int cset_hash(Chess *game)
{
	int i;

	game->hash = 0;
	for (i = 0; i < 64; ++i)
		if (game->color[i] != EMPTY)
			game->hash ^= game->hash_piece[color[i]][game->piece[i]][i];
	if (game->side == DARK)
		game->hash ^= game->hash_side;
	if (game->ep != -1)
		game->hash ^= game->hash_ep[game->ep];

	return 0;
}


/* Board functions */
/* init_board
 *
 * This function sets the board to the initial game state.
 */

static int cinit_board(Chess *game)
{
	int i;

	for (i = 0; i < 64; ++i) {
		game->color[i] = init_color[i];
		game->piece[i] = init_piece[i];
	}
	game->side = LIGHT;
	game->xside = DARK;
	game->castle = 15;
	game->ep = -1;
	game->fifty = 0;
	game->ply = 0;
	game->hply = 0;
	cset_hash(game);  /* init_hash() must be called before this function */
	game->first_move[0] = 0;

	return 0;
}


/* Chess functions */
Chess *create_game(void)
{
	Chess *game;
	int i, j;

	game = (Chess *) malloc(sizeof(Chess));
	cinit_hash(game);
	cinit_board(game);
	
	game->white = game->black = NULL;
	game->turn = 1;
	game->result = 0;
	for (i = 0; i < MAX_MOVES; i++)
		for (j = 0; j < 5; j++) {
			game->white_move[i][j] = '\0';
			game->black_move[i][j] = '\0';
		}

	return game;
}

int *destroy_game(Chess *game)
{
	free(game);

	return 0;
}

int display_board(Chess *game)
{
	int i;
	
	printf("\n8 ");
	for (i = 0; i < 64; ++i) {
		switch (game->color[i]) {
			case EMPTY:
				printf(" .");
				break;
			case LIGHT:
				printf(" %c", piece_char[game->piece[i]]);
				break;
			case DARK:
				printf(" %c", piece_char[game->piece[i]] + ('a' - 'A'));
				break;
		}
		if ((i + 1) % 8 == 0 && i != 63)
			printf("\n%d ", 7 - ROW(i));
	}
	printf("\n\n   a b c d e f g h\n\n");

	return 0;
}

int display_info(Chess *game)
{
	printf("Turn: %d\n", game->turn);
	if (game->side == LIGHT) {
		printf("White's turn to move.\n");
		printf("The previous move was %s.\n", game->black_move[game->turn]);
	} else {
		printf("Black's turn to move\n.");
		printf("The previous move was %s.\n", game->white_move[game->turn]);
	}

	return 0;
}

int display_moves(Chess *game)
{
	int i;

	for (i = 1; i < game->turn; i++)
		printf("%d. %s %s\n", i, game->white_move[i], game->black_move[i]);

	return 0;
}

Move *list_moves(Chess *game, Board *board, int *n)
{
	int n_moves;

	/* gen is a tscp function. It generates pseudo-legal moves and saves them
	 * to the global array gen_dat and modifies first_move[ply+1] to count the
	 * number of moves and track the moves indices in gen_dat.
	 */
	gen(); 
	n_moves = first_move[ply + 1] - first_move[ply];
	printf("n moves %d.\n", n_moves);
	//g = &gen_dat[first_move[ply + 1]++];
	// copy from tscp global variable ... to struct chess_t array of moves.
	return NULL;
}


/* cgen
 *
 * This function generates pseudo-legal moves for the current position. A
 * pseduo-legal move is a move that respects a pieces move pattern but could
 * result in check. This function scans the board to find friendly pieces and
 * then determines what squares they attack. When it finds a piece/square
 * combination, it calls gen_push to put the move on the move stack. It also
 * scans for castling moves and en passsant moves, in addition to regular
 * moves. */

static int cgen(Chess *game)
{
	int i, j, n;

	/* so far, we have no moves for the current ply */
	first_move[ply + 1] = first_move[ply];

	for (i = 0; i < 64; ++i)
		if (game->color[i] == game->side) {
			if (game->piece[i] == PAWN) {
				if (game->side == LIGHT) {
					if (COL(i) != 0 && game->color[i - 9] == DARK)
						cgen_push(game, i, i - 9, 17);
					if (COL(i) != 7 && game->color[i - 7] == DARK)
						cgen_push(game, i, i - 7, 17);
					if (color[i - 8] == EMPTY) {
						cgen_push(game, i, i - 8, 16);
						if (i >= 48 && game->color[i - 16] == EMPTY)
							cgen_push(game, i, i - 16, 24);
					}
				}
				else {
					if (COL(i) != 0 && game->color[i + 7] == LIGHT)
						cgen_push(game, i, i + 7, 17);
					if (COL(i) != 7 && game->color[i + 9] == LIGHT)
						cgen_push(game, i, i + 9, 17);
					if (game->color[i + 8] == EMPTY) {
						cgen_push(game, i, i + 8, 16);
						if (i <= 15 && game->color[i + 16] == EMPTY)
							cgen_push(game, i, i + 16, 24);
					}
				}
			}
			else
				for (j = 0; j < offsets[game->piece[i]]; ++j)
					for (n = i;;) {
						n = mailbox[mailbox64[n] + offset[game->piece[i]][j]];
						if (n == -1)
							break;
						if (game->color[n] != EMPTY) {
							if (game->color[n] == game->xside)
								cgen_push(game, i, n, 1);
							break;
						}
						cgen_push(game, i, n, 0);
						if (!slide[game->piece[i]])
							break;
					}
		}

	/* generate castle moves */
	if (game->side == LIGHT) {
		if (game->castle & 1)
			cgen_push(game, E1, G1, 2);
		if (game->castle & 2)
			cgen_push(game, E1, C1, 2);
	}
	else {
		if (game->castle & 4)
			cgen_push(game, E8, G8, 2);
		if (game->castle & 8)
			cgen_push(game, E8, C8, 2);
	}
	
	/* generate en passant moves */
	if (game->ep != -1) {
		if (game->side == LIGHT) {
			if (COL(game->ep) != 0 && game->color[game->ep + 7] == LIGHT && game->piece[game->ep + 7] == PAWN)
				cgen_push(game, game->ep + 7, game->ep, 21);
			if (COL(game->ep) != 7 && color[game->ep + 9] == LIGHT && piece[game->ep + 9] == PAWN)
				cgen_push(game, game->ep + 9, game->ep, 21);
		}
		else {
			if (COL(game->ep) != 0 && game->color[game->ep - 9] == DARK && game->piece[game->ep - 9] == PAWN)
				cgen_push(game, game->ep - 9, game->ep, 21);
			if (COL(game->ep) != 7 && game->color[game->ep - 7] == DARK && game->piece[game->ep - 7] == PAWN)
				cgen_push(game, game->ep - 7, game->ep, 21);
		}
	}

	return 0;
}


/* cgen_push() puts a move on the move stack, unless it's a
   pawn promotion that needs to be handled by gen_promote().
   It also assigns a score to the move for alpha-beta move
   ordering. If the move is a capture, it uses MVV/LVA
   (Most Valuable Victim/Least Valuable Attacker). Otherwise,
   it uses the move's history heuristic value. Note that
   1,000,000 is added to a capture move's score, so it
   always gets ordered above a "normal" move. */

static int cgen_push(Chess *game, int from, int to, int bits)
{
	gen_t *g;
	
	if (bits & 16) {
		if (game->side == LIGHT) {
			if (to <= H8) {
				cgen_promote(game, from, to, bits);
				return;
			}
		}
		else {
			if (to >= A1) {
				cgen_promote(game, from, to, bits);
				return;
			}
		}
	}
	g = &gen_dat[first_move[ply + 1]++];
	g->m.b.from = (char)from;
	g->m.b.to = (char)to;
	g->m.b.promote = 0;
	g->m.b.bits = (char)bits;
	if (color[to] != EMPTY)
		g->score = 1000000 + (piece[to] * 10) - piece[from];
	else
		g->score = history[from][to];
}
int run_game(Chess *game)
{
	return 0;
}



/* Player functions */
Player *create_player(char *name, int color, Move_func *get_move)

{
	Player *player;

	player = (Player *) malloc(sizeof(Player));
	player->name = name;
	player->color = color;
	player->get_move = get_move;

	return player;
}


int *destroy_player(Player *player)
{
	free(player);

	return 0;
}


int display_player(Player *player)
{
	if (player->color == LIGHT)
		printf("%s is white.\n", player->name);
	else
		printf("%s is black.\n", player->name);

	return 0;
}

/*
int user_move(Chess *game, char *move)
{

	moves = list_moves(Chess *game,   
*/
/*
int reset_game(void)
{
*/
	/* First initialize the data used by tcsp in order to play a game.
	 * Then initialize the data needed for doing reinforcement learning
	 * on top of playing a game. */
/*
	reset_tscp();
	reset_reinforce();

	return 0;
}

static int init_tscp(void)
{
*/
	/* Initializes the hash values for the pieces, side and en passant */
	//init_hash(); 
	//init_board();
	//open_book();
	/* Generates pseudo-legal moves for the current position. */
	//gen();

	//computer_side = EMPTY;
	/* the engine will search for max_time milliseconds or until it finishes
   	searching max_depth ply. */
	//max_time = 1 << 25;
	//max_depth = 4;

	//return 0;
//}

/*
static int reset_tscp(void)
{
	computer_side = EMPTY;
	init_board();
	gen();

	return 0;
}
*/
